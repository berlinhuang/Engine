//
// Created by root on 17-9-4.
//
/*
 * 当析构函数遇到多线程,当一个对象能被多个线程同时看到,那么对象的销毁时机就变得模糊不清了,可能出现多种竞争条件race condition:
 * 1. 在即将析构一个对象时,如何得知此刻是否有别的线程正在执行该对象的成员函数
 * 2. 如何保证在执行成员函数期间,对象不会在另一个线程被析构
 * 3. 在调用某个对象的成员函数之前,如何得知这个对象还活着? 它的析构函数不会碰巧执行到一半?
 * 4. 记住share_ptr的用法.
 *
 * 线程安全:三个条件
 * 1. 多个线程同时访问时,其表现出正确的行为
 * 2. 无论os如何调度这些线程,无论这些线程的执行顺序如何交织
 * 3. 调用端代码无须额外的同步或其他协调动作
 * c++标准库中的大多数class都不是线程安全的,包括std::string,vector,map,必须加深能够额外的锁才可以供多个线程同时访问
 *
 *
 * c++可能出现的内存有一下几个方面:
 * 1. 缓冲区溢出 buffer overrun
 * 2. 空悬指针/野指针
 * 3. 重复释放 double delete
 * 4. 内存泄露 memkory leak
 * 5. 不配对的new[]/delete
 * 6. 内存碎片 memory
 *
 *
 * 正确使用智能指针share_ptr/weak_ptr解决前面的5个问题
 * 1. 缓冲区溢出,用std::vector<char>/std::string或自己编写buffer class管理缓冲区,自动记住缓冲区的长度,公国成员函数而不是裸指针来修改缓冲区.
 * 2. 空悬指针/野指针,使用share_ptr/weak_ptr
 * 3. 重复释放,利用scopted_ptr,只在对象析构的时候释放一次
 * 4. 内存泄露:利用scopted_ptr,对象析构的时候自动释放内存
 * 5. 不配对的new[]/delete:把new[]统统替换为std::vector/scoped_array
 *
 * 对象的创建,  要做到线程安全,唯一的要求就是在狗仔期间不要泄露this指针:
 * 1. 不要在构造函数中注册任何回调
 * 2. 也不要在构造函数中把this指针传递给跨线程的对象
 * 3. 即便在构造函数最后一行也不行

 */
